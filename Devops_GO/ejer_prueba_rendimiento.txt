Pruebas de Rendimiento

Veamos un ejemplo para entender mejor.

Supongamos que deseamos almacenar el valor de un string que se va construyendo a través de un loop. Para ello probaremos 3 formas diferentes de implementar dicha funcionalidad.

A continuación creamos el archivo "longstring.go", con el siguiente contenido:


package longstring
 
import (
    "bytes"
    "strings"
)
 
func MedianteConcatenacion(longitud int) string {
    var s string
    for i := 0; i < longitud; i++ {
        s += "texto"
    }
    return s
}
 
func MedianteArreglo(longitud int) string {
    s := []string{}
    for i := 0; i < longitud; i++ {
        s = append(s, "texto")
    }
    return strings.Join(s, "")
}
 
func MedianteBuffer(longitud int) string {
    var buffer bytes.Buffer
    for i := 0; i < longitud; i++ {
        buffer.WriteString("texto")
    }
    return buffer.String()
}


    

En este archivo podemos ver que tenemos 3 funciones que hacen la misma operación de ir construyendo este string de salida. El número de ciclos realizados por el loop dependen del parámetro longitud. Las 3 diferentes formas en las que se construye el string son las siguientes:

    MedianteConcatenacion
    MedianteArreglo
    MedianteBuffer

Ahora creamos el archivo de pruebas de benchmark, estas a diferencia de las pruebas de test tienen el prefijo Benchmark y reciben un parámetro *testing.B. El argumento contiene un valor N que representa el número de veces que el loop se va a repetir, este valor es ajustado de forma automática por Golang. En cada uno de los casos invocamos cada uno de los distintos métodos.

A continuación creamos el archivo "longstring_test.go", con el siguiente contenido:


package longstring
 
import "testing"
 
func BenchmarkMedianteConcatenacion(b *testing.B) {
    for i := 0; i < b.N; i++ {
        MedianteConcatenacion(100)
    }
}
 
func BenchmarkMedianteArreglo(b *testing.B) {
    for i := 0; i < b.N; i++ {
        MedianteArreglo(100)
    }
}
 
func BenchmarkMedianteBuffer(b *testing.B) {
    for i := 0; i < b.N; i++ {
        MedianteBuffer(100)
    }
}



    

Ejecutamos el archivo de pruebas para ver los resultados:

go test -bench=.

En la salida obtenemos los resultados del benchmark.


goos: darwin
goarch: amd64
pkg: .../benchmark
BenchmarkMedianteConcatenacion-8      200000          7916 ns/op
BenchmarkMedianteArreglo-8            500000          2464 ns/op
BenchmarkMedianteBuffer-8            1000000          1429 ns/op
PASS
ok      .../benchmark    4.378s

    

Con el resultado de las pruebas, podemos darnos cuenta que basado en el Benchmark, el método más idóneo es BenchmarkMedianteBuffer.
