Veamos un ejemplo de pruebas con el lenguaje de programación Go.

Vamos a crear un paquete sencillo, el nombre del archivo será “calculadora.go” y tendrá el siguiente contenido:

/*package main
	
import "fmt"
 
func main() {
	suma := Suma(2, 2)
	fmt.Println("El resultado de la suma es: ", suma)
	
	resta := Resta(2, 2)
	fmt.Println("El resultado de la resta es: ", resta)
	
	multiplicacion := Multiplicacion(2, 2)
	fmt.Println("El resultado de la multiplicacion es: ", multiplicacion)
 
	division := Division(2, 2)
	fmt.Println("El resultado de la division es: ", division)
}
 
func Suma(numero1, numero2 int) (resultado int) {
	resultado = numero1 + numero2
	return
}
 
func Resta(numero1, numero2 int) (resultado int) {
	resultado = numero1 - numero2
	return
}
 
func Multiplicacion(numero1, numero2 int) (resultado int) {
	resultado = numero1 * numero2
	return
}
 
func Division(numero1, numero2 int) (resultado int) {
	resultado = numero1 / numero2
	return
}
*/

Para probar el código, basta con el ejecutar el comando:


/*go run calculadora.go*/

el cual nos presenta el siguiente resultado:


El resultado de la suma es:  4
El resultado de la resta es:  0
El resultado de la multiplicacion es:  4
El resultado de la division es:  1
      

El código anterior cuenta con 4 funciones muy sencillas para la calculadora: Suma, Resta, Multiplicación y División. En todos los casos, se recibe dos enteros y devuelve un entero. Ahora supongamos que quisiéramos asegurarnos de que el resultado de la operación con ambos valores es correcto, creemos nuestro primer archivo de pruebas unitarias.

Empezar a escribir tests automatizados en Go es tan fácil que no requiere de librerías externas, como sí ocurre en otros lenguajes (véase PHPUnit o JUnit). En esta ocasión, el core de Go nos proporciona, tanto los paquetes necesarios (testing) como el binario para la ejecución de los mismos (go test).

Nombrando nuestro archivo de pruebas

Cuando creemos un archivo para pruebas es importante nombrarlo con el sufijo "_test.go". Puede dividir sus pruebas en varios archivos que siguen esta convención.
Por ejemplo:

"whatever1_test.go", "whatever2_test.go", etc.

Debes poner tus funciones de prueba en estos archivos de prueba. Para uso de nuestro ejemplo creamos el archivo "calculadora_test.go" y le incluimos el siguiente contenido:


package main
 
import "testing"
import "fmt"
	
func TestSuma(t *testing.T) {
	suma := Suma(7, 7)
	if suma != 14 {
		t.Error("Se esperaba 30 y se obtuvo", suma)
	}
	
	fmt.Println("Prueba de suma exitosa")
}    
      

En este código Podemos observar lo siguiente:

En Go todas las funciones de testing deben iniciar con la palabra "Test" seguido por un nombre cualquiera, usaremos la palabra Suma para que nuestro cerebro la asocie con la función que queremos probar.

Como sabemos que la suma de 7 y 7 es 14, si llega a ser diferente de eso es porque algo anda mal, en ese caso usamos la función Error para indicar que la prueba falló.

Puede que en este punto parezca tonto decir esto pero... Se considera que la prueba fue exitosa si no se cometieron errores.

Para correr la prueba, en la terminal usamos el siguiente comando:

go test

Si todo ha ido bien veremos la palabra PASS, y si algo ha fallado, veremos la palabra FAIL junto a nuestro mensaje de error y la línea del archivo en donde las cosas fallaron.


Prueba de suma exitosa
PASS
ok  	calculadora	0.132s

      

Podemos agregar el parámetro -cover, el cual nos incluirá un indicador de la cobertura que tenemos de las pruebas unitarias.

El comando con el parámetro "-cover", queda de la siguiente manera:

go test - cover

Y al ejecutarlo, vemos el siguiente resultado:


Prueba de suma exitosa
PASS
coverage: 12.5% of statements
ok  	calculadora	0.284s


      

Podemos observar que la cobertura de nuestras pruebas es del 12.5%, por lo que para incrementarla necesitamos completar las pruebas unitarias necesarias para las funciones restantes.

En este momento podemos agregar más pruebas a nuestro archivo test, quedando de la siguiente manera:


package main
 
import "testing"
import "fmt"
	
func TestSuma(t *testing.T) {
	suma := Suma(7, 7)
	if suma != 14 {
		t.Error("Se esperaba 30 y se obtuvo", suma)
	}
	
	fmt.Println("Prueba de suma exitosa")
}
 
func TestResta(t *testing.T) {
	resta := Resta(7, 7)
	if resta != 0 {
		t.Error("Se esperaba 30 y se obtuvo", resta)
	}
	
	fmt.Println("Prueba de resta exitosa")
}
 
func TestMultiplicacion(t *testing.T) {
	multiplicacion := Multiplicacion(7, 7)
	if multiplicacion != 49 {
		t.Error("Se esperaba 30 y se obtuvo", multiplicacion)
	}
	
	fmt.Println("Prueba de multiplicacion exitosa")
}
 
func TestDivision(t *testing.T) {
	division := Division(7, 7)
	if division != 1 {
		t.Error("Se esperaba 30 y se obtuvo", division)
	}
	
	fmt.Println("Prueba de division exitosa")
}
 
      

Ahora ya tenemos las pruebas unitarias para las funciones: Suma, Resta, Multiplicacion y Division por lo que solo queda ejecutar el archivo de prueba ya modificado, mediante el comando:

go test - cover

Obtendremos el siguiente resultado:


Prueba de suma exitosa
Prueba de resta exitosa
Prueba de multiplicacion exitosa
Prueba de division exitosa
PASS
coverage: 50.0% of statements
ok  	calculadora	0.127s

      

Si observamos el resultado actual vemos que hemos incrementado nuestro porcentaje de cobertura, pero no hasta el 100%. Esto se debe a la existencia de la función "main", en el archivo "calculadora.go". Por lo que si comentamos dicha función:


package main
	
/*import "fmt"
 
func main() {
	suma := Suma(2, 2)
	fmt.Println("El resultado de la suma es: ", suma)
	
	resta := Resta(2, 2)
	fmt.Println("El resultado de la resta es: ", resta)
	
	multiplicacion := Multiplicacion(2, 2)
	fmt.Println("El resultado de la multiplicacion es: ", multiplicacion)
 
	division := Division(2, 2)
	fmt.Println("El resultado de la division es: ", division)
}*/
 
func Suma(numero1, numero2 int) (resultado int) {
	resultado = numero1 + numero2
	return
}
 
func Resta(numero1, numero2 int) (resultado int) {
	resultado = numero1 - numero2
	return
}
 
func Multiplicacion(numero1, numero2 int) (resultado int) {
	resultado = numero1 * numero2
	return
}
 
func Division(numero1, numero2 int) (resultado int) {
	resultado = numero1 / numero2
	return
}

Y volvemos a ejecutar el comando:

go test - cover

Vemos que el resultado queda de la siguiente manera:


Prueba de suma exitosa
Prueba de resta exitosa
Prueba de multiplicacion exitosa
Prueba de division exitosa
PASS
coverage: 100.0% of statements
ok  	calculadora	0.122s

      

Ahora ya tenemos el 100% de cobertura de nuestras unitarias.




